import os
from pathlib import Path
from app.input.file_metadata import FileMetadata

def save_converted_code(
    original_metadata: FileMetadata,
    converted_code: str,
    target_language: str,
    base_output_dir: str = "app/validation"  # Changed to validation layer
):
    """
    Saves the converted code to a file, preserving directory structure,
    and converting file extension to match target language.
    """

    # Ensure lowercase for directory naming
    target_lang_folder = target_language.lower().replace("#", "sharp")
    original_path = original_metadata.path

    # Try to get relative path, fallback to filename if not possible
    try:
        relative_path = original_path.relative_to(Path.cwd())
    except ValueError:
        relative_path = Path(os.path.basename(original_path))

    # Adjust filename extension
    new_extension = get_extension_for_language(target_language)
    output_relative_path = relative_path.with_suffix(new_extension)

    # Full output path
    output_path = Path(base_output_dir) / target_lang_folder / output_relative_path

    # Ensure directory exists
    output_path.parent.mkdir(parents=True, exist_ok=True)

    # Add optional header to indicate this is machine-generated
    header = f"// This file was auto-generated by GenAI from {original_metadata.language} â†’ {target_language}\n\n"

    with open(output_path, "w", encoding="utf-8") as f:
        f.write(header + converted_code)

    print(f"Saved converted file: {output_path}")


def get_extension_for_language(language: str) -> str:
    """
    Maps a language to a default file extension.
    """
    mapping = {
        "python": ".py",
        "java": ".java",
        "r": ".r",
        "sql": ".sql",
        "javascript": ".js",
        "typescript": ".ts",
        "c++": ".cpp",
        "c#": ".cs",
        "json": ".json"
    }
    return mapping.get(language.lower(), ".txt")
